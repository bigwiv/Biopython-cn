<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Chapter 20 Advanced &mdash; biopython_en 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="biopython_en 0.1 documentation" href="index.html" />
    <link rel="next" title="Chapter 21 Where to go from here – contributing to Biopython" href="chr21.html" />
    <link rel="prev" title="Chapter 19 The Biopython testing framework" href="chr19.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="chr21.html" title="Chapter 21 Where to go from here – contributing to Biopython"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="chr19.html" title="Chapter 19 The Biopython testing framework"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">biopython_en 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="chapter-20-advanced">
<h1>Chapter 20  Advanced<a class="headerlink" href="#chapter-20-advanced" title="Permalink to this headline">¶</a></h1>
<div class="section" id="parser-design">
<h2>20.1  Parser Design<a class="headerlink" href="#parser-design" title="Permalink to this headline">¶</a></h2>
<p>Many of the older Biopython parsers were built around an event-oriented
design that includes Scanner and Consumer objects.</p>
<p>Scanners take input from a data source and analyze it line by line,
sending off an event whenever it recognizes some information in the
data. For example, if the data includes information about an organism
name, the scanner may generate an <tt class="docutils literal"><span class="pre">organism_name</span></tt> event whenever it
encounters a line containing the name.</p>
<p>Consumers are objects that receive the events generated by Scanners.
Following the previous example, the consumer receives the
<tt class="docutils literal"><span class="pre">organism_name</span></tt> event, and the processes it in whatever manner
necessary in the current application.</p>
<p>This is a very flexible framework, which is advantageous if you want to
be able to parse a file format into more than one representation. For
example, the <tt class="docutils literal"><span class="pre">Bio.GenBank</span></tt> module uses this to construct either
<tt class="docutils literal"><span class="pre">SeqRecord</span></tt> objects or file-format-specific record objects.</p>
<p>More recently, many of the parsers added for <tt class="docutils literal"><span class="pre">Bio.SeqIO</span></tt> and
<tt class="docutils literal"><span class="pre">Bio.AlignIO</span></tt> take a much simpler approach, but only generate a single
object representation (<tt class="docutils literal"><span class="pre">SeqRecord</span></tt> and <tt class="docutils literal"><span class="pre">MultipleSeqAlignment</span></tt>
objects respectively). In some cases the <tt class="docutils literal"><span class="pre">Bio.SeqIO</span></tt> parsers actually
wrap another Biopython parser - for example, the <tt class="docutils literal"><span class="pre">Bio.SwissProt</span></tt>
parser produces SwissProt format specific record objects, which get
converted into <tt class="docutils literal"><span class="pre">SeqRecord</span></tt> objects.</p>
</div>
<div class="section" id="substitution-matrices">
<h2>20.2  Substitution Matrices<a class="headerlink" href="#substitution-matrices" title="Permalink to this headline">¶</a></h2>
<div class="section" id="subsmat">
<h3>20.2.1  SubsMat<a class="headerlink" href="#subsmat" title="Permalink to this headline">¶</a></h3>
<p>This module provides a class and a few routines for generating
substitution matrices, similar to BLOSUM or PAM matrices, but based on
user-provided data. Additionally, you may select a matrix from
MatrixInfo.py, a collection of established substitution matrices. The
<tt class="docutils literal"><span class="pre">SeqMat</span></tt> class derives from a dictionary:</p>
<div class="code python highlight-python"><pre>class SeqMat(dict)</pre>
</div>
<p>The dictionary is of the form
<tt class="docutils literal"><span class="pre">{(i1,j1):n1,</span> <span class="pre">(i1,j2):n2,...,(ik,jk):nk}</span></tt> where i, j are alphabet
letters, and n is a value.</p>
<ol class="arabic">
<li><p class="first">Attributes</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">self.alphabet</span></tt>: a class as defined in Bio.Alphabet</li>
<li><tt class="docutils literal"><span class="pre">self.ab_list</span></tt>: a list of the alphabet’s letters, sorted. Needed
mainly for internal purposes</li>
</ol>
</li>
<li><p class="first">Methods</p>
<ol class="arabic">
<li><div class="code python first highlight-python"><pre>__init__(self,data=None,alphabet=None, mat_name='', build_later=0):</pre>
</div>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">data</span></tt>: can be either a dictionary, or another SeqMat
instance.</li>
<li><tt class="docutils literal"><span class="pre">alphabet</span></tt>: a Bio.Alphabet instance. If not provided,
construct an alphabet from data.</li>
<li><tt class="docutils literal"><span class="pre">mat_name</span></tt>: matrix name, such as &#8220;BLOSUM62&#8221; or &#8220;PAM250&#8221;</li>
<li><tt class="docutils literal"><span class="pre">build_later</span></tt>: default false. If true, user may supply only
alphabet and empty dictionary, if intending to build the matrix
later. this skips the sanity check of alphabet size vs. matrix
size.</li>
</ol>
</li>
<li><div class="code python first highlight-python"><div class="highlight"><pre><span class="n">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">obs_freq_mat</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">obs_freq_mat</span></tt>: an observed frequency matrix. Returns the
matrix’s entropy, based on the frequency in <tt class="docutils literal"><span class="pre">obs_freq_mat</span></tt>.
The matrix instance should be LO or SUBS.</li>
</ol>
</li>
<li><div class="code python first highlight-python"><div class="highlight"><pre><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>Calculates the sum of values for each letter in the matrix’s
alphabet, and returns it as a dictionary of the form
<tt class="docutils literal"><span class="pre">{i1:</span> <span class="pre">s1,</span> <span class="pre">i2:</span> <span class="pre">s2,...,in:sn}</span></tt>, where:</p>
<ul class="simple">
<li>i: an alphabet letter;</li>
<li>s: sum of all values in a half-matrix for that letter;</li>
<li>n: number of letters in alphabet.</li>
</ul>
</li>
<li><div class="code python first highlight-python"><div class="highlight"><pre><span class="n">print_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="s">&quot;</span><span class="si">%4d</span><span class="s">&quot;</span><span class="p">,</span><span class="n">bottomformat</span><span class="o">=</span><span class="s">&quot;</span><span class="si">%4s</span><span class="s">&quot;</span><span class="p">,</span><span class="n">alphabet</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<p>prints the matrix to file handle f. <tt class="docutils literal"><span class="pre">format</span></tt> is the format field
for the matrix values; <tt class="docutils literal"><span class="pre">bottomformat</span></tt> is the format field for
the bottom row, containing matrix letters. Example output for a
3-letter alphabet matrix:</p>
<div class="code python highlight-python"><pre>A 23
B 12 34
C 7  22  27
  A   B   C</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">alphabet</span></tt> optional argument is a string of all characters
in the alphabet. If supplied, the order of letters along the axes
is taken from the string, rather than by alphabetical order.</p>
</li>
</ol>
</li>
<li><p class="first">Usage</p>
<p>The following section is laid out in the order by which most people
wish to generate a log-odds matrix. Of course, interim matrices can
be generated and investigated. Most people just want a log-odds
matrix, that’s all.</p>
<ol class="arabic">
<li><p class="first">Generating an Accepted Replacement Matrix</p>
<p>Initially, you should generate an accepted replacement matrix
(ARM) from your data. The values in ARM are the counted number of
replacements according to your data. The data could be a set of
pairs or multiple alignments. So for instance if Alanine was
replaced by Cysteine 10 times, and Cysteine by Alanine 12 times,
the corresponding ARM entries would be:</p>
<div class="code python highlight-python"><pre>('A','C'): 10, ('C','A'): 12</pre>
</div>
<p>as order doesn’t matter, user can already provide only one entry:</p>
<div class="code python highlight-python"><pre>('A','C'): 22</pre>
</div>
<p>A SeqMat instance may be initialized with either a full (first
method of counting: 10, 12) or half (the latter method, 22)
matrices. A full protein alphabet matrix would be of the size
20x20 = 400. A half matrix of that alphabet would be 20x20/2 +
20/2 = 210. That is because same-letter entries don’t change. (The
matrix diagonal). Given an alphabet size of N:</p>
<ol class="arabic simple">
<li>Full matrix size:N*N</li>
<li>Half matrix size: N(N+1)/2</li>
</ol>
<p>The SeqMat constructor automatically generates a half-matrix, if a
full matrix is passed. If a half matrix is passed, letters in the
key should be provided in alphabetical order: (’A’,’C’) and not
(’C’,A’).</p>
<p>At this point, if all you wish to do is generate a log-odds
matrix, please go to the section titled Example of Use. The
following text describes the nitty-gritty of internal functions,
to be used by people who wish to investigate their
nucleotide/amino-acid frequency data more thoroughly.</p>
</li>
<li><p class="first">Generating the observed frequency matrix (OFM)</p>
<p>Use:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">OFM</span> <span class="o">=</span> <span class="n">SubsMat</span><span class="o">.</span><span class="n">_build_obs_freq_mat</span><span class="p">(</span><span class="n">ARM</span><span class="p">)</span>
</pre></div>
</div>
<p>The OFM is generated from the ARM, only instead of replacement
counts, it contains replacement frequencies.</p>
</li>
<li><p class="first">Generating an expected frequency matrix (EFM)</p>
<p>Use:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">EFM</span> <span class="o">=</span> <span class="n">SubsMat</span><span class="o">.</span><span class="n">_build_exp_freq_mat</span><span class="p">(</span><span class="n">OFM</span><span class="p">,</span><span class="n">exp_freq_table</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">exp_freq_table</span></tt>: should be a FreqTable instance. See
section <a class="reference external" href="#sec:freq_table">20.2.2</a> for detailed information
on FreqTable. Briefly, the expected frequency table has the
frequencies of appearance for each member of the alphabet. It
is implemented as a dictionary with the alphabet letters as
keys, and each letter’s frequency as a value. Values sum to 1.</li>
</ol>
<p>The expected frequency table can (and generally should) be
generated from the observed frequency matrix. So in most cases you
will generate <tt class="docutils literal"><span class="pre">exp_freq_table</span></tt> using:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">exp_freq_table</span> <span class="o">=</span> <span class="n">SubsMat</span><span class="o">.</span><span class="n">_exp_freq_table_from_obs_freq</span><span class="p">(</span><span class="n">OFM</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EFM</span> <span class="o">=</span> <span class="n">SubsMat</span><span class="o">.</span><span class="n">_build_exp_freq_mat</span><span class="p">(</span><span class="n">OFM</span><span class="p">,</span><span class="n">exp_freq_table</span><span class="p">)</span>
</pre></div>
</div>
<p>But you can supply your own <tt class="docutils literal"><span class="pre">exp_freq_table</span></tt>, if you wish</p>
</li>
<li><p class="first">Generating a substitution frequency matrix (SFM)</p>
<p>Use:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">SFM</span> <span class="o">=</span> <span class="n">SubsMat</span><span class="o">.</span><span class="n">_build_subs_mat</span><span class="p">(</span><span class="n">OFM</span><span class="p">,</span><span class="n">EFM</span><span class="p">)</span>
</pre></div>
</div>
<p>Accepts an OFM, EFM. Provides the division product of the
corresponding values.</p>
</li>
<li><p class="first">Generating a log-odds matrix (LOM)</p>
<p>Use:</p>
<div class="code python highlight-python"><pre>LOM=SubsMat._build_log_odds_mat(SFM[,logbase=10,factor=10.0,round_digit=1])</pre>
</div>
<ol class="arabic simple">
<li>Accepts an SFM.</li>
<li><tt class="docutils literal"><span class="pre">logbase</span></tt>: base of the logarithm used to generate the
log-odds values.</li>
<li><tt class="docutils literal"><span class="pre">factor</span></tt>: factor used to multiply the log-odds values. Each
entry is generated by log(LOM[key])*factor And rounded to the
<tt class="docutils literal"><span class="pre">round_digit</span></tt> place after the decimal point, if required.</li>
</ol>
</li>
</ol>
</li>
<li><p class="first">Example of use</p>
<p>As most people would want to generate a log-odds matrix, with minimum
hassle, SubsMat provides one function which does it all:</p>
<div class="code python highlight-python"><pre>make_log_odds_matrix(acc_rep_mat,exp_freq_table=None,logbase=10,
                      factor=10.0,round_digit=0):</pre>
</div>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">acc_rep_mat</span></tt>: user provided accepted replacements matrix</li>
<li><tt class="docutils literal"><span class="pre">exp_freq_table</span></tt>: expected frequencies table. Used if provided,
if not, generated from the <tt class="docutils literal"><span class="pre">acc_rep_mat</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">logbase</span></tt>: base of logarithm for the log-odds matrix. Default
base 10.</li>
<li><tt class="docutils literal"><span class="pre">round_digit</span></tt>: number after decimal digit to which result should
be rounded. Default zero.</li>
</ol>
</li>
</ol>
</div>
<div class="section" id="freqtable">
<h3>20.2.2  FreqTable<a class="headerlink" href="#freqtable" title="Permalink to this headline">¶</a></h3>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">FreqTable</span><span class="o">.</span><span class="n">FreqTable</span><span class="p">(</span><span class="n">UserDict</span><span class="o">.</span><span class="n">UserDict</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic">
<li><p class="first">Attributes:</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">alphabet</span></tt>: A Bio.Alphabet instance.</li>
<li><tt class="docutils literal"><span class="pre">data</span></tt>: frequency dictionary</li>
<li><tt class="docutils literal"><span class="pre">count</span></tt>: count dictionary (in case counts are provided).</li>
</ol>
</li>
<li><p class="first">Functions:</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">read_count(f)</span></tt>: read a count file from stream f. Then convert
to frequencies</li>
<li><tt class="docutils literal"><span class="pre">read_freq(f)</span></tt>: read a frequency data file from stream f. Of
course, we then don’t have the counts, but it is usually the
letter frquencies which are interesting.</li>
</ol>
</li>
<li><p class="first">Example of use: The expected count of the residues in the database is
sitting in a file, whitespace delimited, in the following format
(example given for a 3-letter alphabet):</p>
<div class="code python highlight-python"><pre>A   35
B   65
C   100</pre>
</div>
<p>And will be read using the <tt class="docutils literal"><span class="pre">FreqTable.read_count(file_handle)</span></tt>
function.</p>
<p>An equivalent frequency file:</p>
<div class="code python highlight-python"><pre>A  0.175
B  0.325
C  0.5</pre>
</div>
<p>Conversely, the residue frequencies or counts can be passed as a
dictionary. Example of a count dictionary (3-letter alphabet):</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="mi">35</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">:</span> <span class="mi">65</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">}</span>
</pre></div>
</div>
<p>Which means that an expected data count would give a 0.5 frequency
for ’C’, a 0.325 probability of ’B’ and a 0.175 probability of ’A’
out of 200 total, sum of A, B and C)</p>
<p>A frequency dictionary for the same data would be:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="mf">0.175</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">:</span> <span class="mf">0.325</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">}</span>
</pre></div>
</div>
<p>Summing up to 1.</p>
<p>When passing a dictionary as an argument, you should indicate whether
it is a count or a frequency dictionary. Therefore the FreqTable
class constructor requires two arguments: the dictionary itself, and
FreqTable.COUNT or FreqTable.FREQ indicating counts or frequencies,
respectively.</p>
<p>Read expected counts. readCount will already generate the frequencies
Any one of the following may be done to geerate the frequency table
(ftab):</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">SubsMat</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ftab</span> <span class="o">=</span> <span class="n">FreqTable</span><span class="o">.</span><span class="n">FreqTable</span><span class="p">(</span><span class="n">my_frequency_dictionary</span><span class="p">,</span><span class="n">FreqTable</span><span class="o">.</span><span class="n">FREQ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ftab</span> <span class="o">=</span> <span class="n">FreqTable</span><span class="o">.</span><span class="n">FreqTable</span><span class="p">(</span><span class="n">my_count_dictionary</span><span class="p">,</span><span class="n">FreqTable</span><span class="o">.</span><span class="n">COUNT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ftab</span> <span class="o">=</span> <span class="n">FreqTable</span><span class="o">.</span><span class="n">read_count</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&#39;myCountFile&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ftab</span> <span class="o">=</span> <span class="n">FreqTable</span><span class="o">.</span><span class="n">read_frequency</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&#39;myFrequencyFile&#39;</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ol>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Chapter 20  Advanced</a><ul>
<li><a class="reference internal" href="#parser-design">20.1  Parser Design</a></li>
<li><a class="reference internal" href="#substitution-matrices">20.2  Substitution Matrices</a><ul>
<li><a class="reference internal" href="#subsmat">20.2.1  SubsMat</a></li>
<li><a class="reference internal" href="#freqtable">20.2.2  FreqTable</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="chr19.html"
                        title="previous chapter">Chapter 19  The Biopython testing framework</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="chr21.html"
                        title="next chapter">Chapter 21  Where to go from here – contributing to Biopython</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/chr20.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="chr21.html" title="Chapter 21 Where to go from here – contributing to Biopython"
             >next</a> |</li>
        <li class="right" >
          <a href="chr19.html" title="Chapter 19 The Biopython testing framework"
             >previous</a> |</li>
        <li><a href="index.html">biopython_en 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, biopythoners.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>