<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第8章 BLAST和其他序列搜索工具(实验性质的代码) &mdash; biopython_cn 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="biopython_cn 0.1 documentation" href="index.html" />
    <link rel="next" title="第9章 访问NCBI Entrez数据库" href="chr09.html" />
    <link rel="prev" title="第7章 BLAST" href="chr07.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="chr09.html" title="第9章 访问NCBI Entrez数据库"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="chr07.html" title="第7章 BLAST"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">biopython_cn 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="blast">
<h1>第8章  BLAST和其他序列搜索工具(<em>实验性质的代码</em>)<a class="headerlink" href="#blast" title="Permalink to this headline">¶</a></h1>
<p><em>WARNING</em>: 这章教程介绍了Biopython中一个 <em>实验的</em> 模块。它正在被加入到
Biopython中，并且以一个预尾期的状态整理到教程当中，这样在我们发布稳定版
的之前可以收到一系列的反馈和并作改进。那时有些细节可能会改变，并且用到
当前 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 模块的脚本也需要更新。切记！为了与NCBI BLAST有关的
代码可以稳定工作，请继续使用第 <a class="reference external" href="#chapter:blast">7</a> 章介绍的Bio.Blast。</p>
<p>生物序列的鉴定是生物信息工作的主要部分。有几个工具像BLAST（可能是最流行
的），FASTA ，HMMER还有许多其它的都有这个功能，每个工具都有独特的算法和
途径。一般来说，这些工具都是用你的序列在数据库中搜索可能的匹配。随着序列
数量的增加（匹配数也会随之增加），将会有成百上千的可能匹配，解析这些结果
无疑变得越来越困难。理所当然，人工解析搜索结果变得不可能。而且你可能会同
时用几种不同的搜索工具，每种工具都有独特的统计方法、规则和输出格式。可以
想象，同时用多种工具搜索多条序列是多么恐怖的事。</p>
<p>我们对此非常了解，所以我们在Biopython构建了 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 亚模块。<tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 模块使从搜索结果中提取信息变得简单，并且可以处理不同工具
的不同标准和规则。<tt class="docutils literal"><span class="pre">SearchIO</span></tt> 和BioPerl中模块名称一致。</p>
<p>在本章中，我们将学习 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 的主要功能，了解它可以做什么。我
们将使用两个主要的搜索工具：BLAST和FASTA。它们只是用来阐明思路，你可以轻
易地把工作流程应用到 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 支持的其他工具中。欢迎你使用我们将要
用到的搜索结果文件。BLAST搜索结果文件可以在
<a class="reference external" href="http://biopython.org/SRC/Tests/Tutorial/my_blast.xml">这里</a> 下载。
BLAT输出结果文件可以在
<a class="reference external" href="http://biopython.org/SRC/Tests/Tutorial/my_blat.psl">这里</a> 下载。两个结果
文件都是用下面这条序列搜索产生的：</p>
<div class="code python highlight-python"><pre>&gt;mystery_seq
CCCTCTACAGGGAAGCGCTTTCTGTTGTCTGAAAGAAAAGAAAGTGCTTCCTTTTAGAGGG</pre>
</div>
<p>BLAST的XML结果是用 <tt class="docutils literal"><span class="pre">blastn</span></tt> 搜索NCBI的 <tt class="docutils literal"><span class="pre">refseq_rna</span></tt> 数据库得到的。对于
BLAT，数据库是2009年2月份的 <tt class="docutils literal"><span class="pre">hg19</span></tt> 人类基因组草图，输出格式是PSL。</p>
<p>我们从 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 的对象模型的介绍开始。这个模型代表你的搜索结果，因
此它是 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 的核心。然后，我们会介绍 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 常用的主要
功能。</p>
<p>现在一切就绪，让我们开始第一步：介绍核心对象模型。</p>
<div class="section" id="searchio">
<h2>8.1  SearchIO对象模型<a class="headerlink" href="#searchio" title="Permalink to this headline">¶</a></h2>
<p>尽管多数搜索工具的输出风格极为不同，但是它们蕴含的理念很相似：</p>
<ul class="simple">
<li>输出文件可能包含一条或更多的搜索查询的结果。</li>
<li>在每次查询中，你会在给定的数据库中得到一个或更多的hit（命中）。</li>
<li>在每个hit中，你会得到一个或更多包含query（查询)序列和数据库序列实际比对的区域。</li>
<li>一些工具如BLAT和Exonerate可能会把这些区域分成几个比对片段（或在BLAT中
称为区块，在Exonerate中称为可能外显子）。这并不是很常见，像BLAST和
HMMER就不这么做。</li>
</ul>
<p>知道这些共性之后，我们决定把它们作为创造 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 对象模型的基础。对
象模型是Python对象组成的嵌套分级系统，每个对象都代表一个上面列出的概念。这些对
象是：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">QueryResult</span></tt>，代表单个搜索查询。</li>
<li><tt class="docutils literal"><span class="pre">Hit</span></tt>，代表单个的数据库hit。<tt class="docutils literal"><span class="pre">Hit</span></tt> 对象包含在 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 中，
每个 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 中有0个或多个 <tt class="docutils literal"><span class="pre">Hit</span></tt> 对象。</li>
<li><tt class="docutils literal"><span class="pre">HSP</span></tt> (high-scoring pair（高分片段）)，代表query和hit序列中有
意义比对的区域。<tt class="docutils literal"><span class="pre">HSP</span></tt> 对象包含在 <tt class="docutils literal"><span class="pre">Hit</span></tt> 对象中，而且每个 <tt class="docutils literal"><span class="pre">Hit</span></tt> 有一个
或更多的 <tt class="docutils literal"><span class="pre">HSP</span></tt> 对象。</li>
<li><tt class="docutils literal"><span class="pre">HSPFragment</span></tt>，代表query和hit序列中单个的邻近比对。 <tt class="docutils literal"><span class="pre">HSPFragment</span></tt>
对象包含在 <tt class="docutils literal"><span class="pre">HSP</span></tt> 对象中。多数的搜索工具如BLAST和HMMER把 <tt class="docutils literal"><span class="pre">HSP</span></tt> 和
<tt class="docutils literal"><span class="pre">HSPFragment</span></tt> 合并，因为一个 <tt class="docutils literal"><span class="pre">HSP</span></tt> 只含有一个 <tt class="docutils literal"><span class="pre">HSPFragment</span></tt>。但是
像BLAT和Exonerate会产生含有多个 <tt class="docutils literal"><span class="pre">HSPFragment</span></tt> 的 <tt class="docutils literal"><span class="pre">HSP</span></tt> 。似乎有些困
惑？不要紧，稍后我们将详细介绍这两个对象。</li>
</ul>
<p>这四个对象是当你用 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 会碰到的。 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 四
个主要方法： <tt class="docutils literal"><span class="pre">read</span></tt> ，<tt class="docutils literal"><span class="pre">parse</span></tt>，<tt class="docutils literal"><span class="pre">index</span></tt> 或 <tt class="docutils literal"><span class="pre">index_db</span></tt> 中任意一个都可
以产生这四个对象。这些方法的会在后面的部分详细介绍。这部分只会用到 <tt class="docutils literal"><span class="pre">read</span></tt> 和
<tt class="docutils literal"><span class="pre">parse</span></tt> ，这两个方法和 <tt class="docutils literal"><span class="pre">Bio.SeqIO</span></tt> 以及 <tt class="docutils literal"><span class="pre">Bio.AlignIO</span></tt> 中的 <tt class="docutils literal"><span class="pre">read</span></tt> 和 <tt class="docutils literal"><span class="pre">parse</span></tt> 方法功
能相似：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">read</span></tt> 用于单query对输出文件进行搜索并且返回一个 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象。</li>
<li><tt class="docutils literal"><span class="pre">parse</span></tt> 用于多query对输出文件进行搜索并且返回一个可以yield <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象的generator。</li>
</ul>
<p>完成这些之后，让我们开始学习每个 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 对象，从 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 开始。</p>
<div class="section" id="queryresult">
<h3>8.1.1  QueryResult<a class="headerlink" href="#queryresult" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">QueryResult</span></tt>，代表单query搜索，每个 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 中有0个或多个 <tt class="docutils literal"><span class="pre">Hit</span></tt> 对象。我们来看看BLAST文件是什么样的：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SearchIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blast_qresult</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s">&#39;my_blast.xml&#39;</span><span class="p">,</span> <span class="s">&#39;blast-xml&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">blast_qresult</span>
<span class="go">Program: blastn (2.2.27+)</span>
<span class="go">  Query: 42291 (61)</span>
<span class="go">         mystery_seq</span>
<span class="go"> Target: refseq_rna</span>
<span class="go">   Hits: ----  -----  ----------------------------------------------------------</span>
<span class="go">            #  # HSP  ID + description</span>
<span class="go">         ----  -----  ----------------------------------------------------------</span>
<span class="go">            0      1  gi|262205317|ref|NR_030195.1|  Homo sapiens microRNA 52...</span>
<span class="go">            1      1  gi|301171311|ref|NR_035856.1|  Pan troglodytes microRNA...</span>
<span class="go">            2      1  gi|270133242|ref|NR_032573.1|  Macaca mulatta microRNA ...</span>
<span class="go">            3      2  gi|301171322|ref|NR_035857.1|  Pan troglodytes microRNA...</span>
<span class="go">            4      1  gi|301171267|ref|NR_035851.1|  Pan troglodytes microRNA...</span>
<span class="go">            5      2  gi|262205330|ref|NR_030198.1|  Homo sapiens microRNA 52...</span>
<span class="go">            6      1  gi|262205302|ref|NR_030191.1|  Homo sapiens microRNA 51...</span>
<span class="go">            7      1  gi|301171259|ref|NR_035850.1|  Pan troglodytes microRNA...</span>
<span class="go">            8      1  gi|262205451|ref|NR_030222.1|  Homo sapiens microRNA 51...</span>
<span class="go">            9      2  gi|301171447|ref|NR_035871.1|  Pan troglodytes microRNA...</span>
<span class="go">           10      1  gi|301171276|ref|NR_035852.1|  Pan troglodytes microRNA...</span>
<span class="go">           11      1  gi|262205290|ref|NR_030188.1|  Homo sapiens microRNA 51...</span>
<span class="go">           12      1  gi|301171354|ref|NR_035860.1|  Pan troglodytes microRNA...</span>
<span class="go">           13      1  gi|262205281|ref|NR_030186.1|  Homo sapiens microRNA 52...</span>
<span class="go">           14      2  gi|262205298|ref|NR_030190.1|  Homo sapiens microRNA 52...</span>
<span class="go">           15      1  gi|301171394|ref|NR_035865.1|  Pan troglodytes microRNA...</span>
<span class="go">           16      1  gi|262205429|ref|NR_030218.1|  Homo sapiens microRNA 51...</span>
<span class="go">           17      1  gi|262205423|ref|NR_030217.1|  Homo sapiens microRNA 52...</span>
<span class="go">           18      1  gi|301171401|ref|NR_035866.1|  Pan troglodytes microRNA...</span>
<span class="go">           19      1  gi|270133247|ref|NR_032574.1|  Macaca mulatta microRNA ...</span>
<span class="go">           20      1  gi|262205309|ref|NR_030193.1|  Homo sapiens microRNA 52...</span>
<span class="go">           21      2  gi|270132717|ref|NR_032716.1|  Macaca mulatta microRNA ...</span>
<span class="go">           22      2  gi|301171437|ref|NR_035870.1|  Pan troglodytes microRNA...</span>
<span class="go">           23      2  gi|270133306|ref|NR_032587.1|  Macaca mulatta microRNA ...</span>
<span class="go">           24      2  gi|301171428|ref|NR_035869.1|  Pan troglodytes microRNA...</span>
<span class="go">           25      1  gi|301171211|ref|NR_035845.1|  Pan troglodytes microRNA...</span>
<span class="go">           26      2  gi|301171153|ref|NR_035838.1|  Pan troglodytes microRNA...</span>
<span class="go">           27      2  gi|301171146|ref|NR_035837.1|  Pan troglodytes microRNA...</span>
<span class="go">           28      2  gi|270133254|ref|NR_032575.1|  Macaca mulatta microRNA ...</span>
<span class="go">           29      2  gi|262205445|ref|NR_030221.1|  Homo sapiens microRNA 51...</span>
<span class="go">           ~~~</span>
<span class="go">           97      1  gi|356517317|ref|XM_003527287.1|  PREDICTED: Glycine ma...</span>
<span class="go">           98      1  gi|297814701|ref|XM_002875188.1|  Arabidopsis lyrata su...</span>
<span class="go">           99      1  gi|397513516|ref|XM_003827011.1|  PREDICTED: Pan panisc...</span>
</pre></div>
</div>
<p>虽然我们才接触对象模型的皮毛，但是你已经可以看到一些有用的信息了。通过调用``QueryResult`` 对象的 <tt class="docutils literal"><span class="pre">print</span></tt> 方法，你可以看到：</p>
<ul class="simple">
<li>程序的名称和版本 (blastn version 2.2.27+)</li>
<li>query的ID，描述和序列长度(ID是42291，描述是 ‘mystery_seq’，长度是61)</li>
<li>搜索的目标数据库 (refseq_rna)</li>
<li>hit结果的快速预览。对于我们的查询序列，有100个可能的hit（表格中表示的是
0-99）对于每个hit，我们可以看到它包含的高分比对片段（HSP)，ID和一个片
段描述。注意， <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 截断了表格，只显示0-29，然后是97-99。</li>
</ul>
<p>现在让我们用同样的步骤来检查BLAT的结果：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blat_qresult</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s">&#39;my_blat.psl&#39;</span><span class="p">,</span> <span class="s">&#39;blat-psl&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">blat_qresult</span>
<span class="go">Program: blat (&lt;unknown version&gt;)</span>
<span class="go">  Query: mystery_seq (61)</span>
<span class="go">         &lt;unknown description&gt;</span>
<span class="go"> Target: &lt;unknown target&gt;</span>
<span class="go">   Hits: ----  -----  ----------------------------------------------------------</span>
<span class="go">            #  # HSP  ID + description</span>
<span class="go">         ----  -----  ----------------------------------------------------------</span>
<span class="go">            0     17  chr19  &lt;unknown description&gt;</span>
</pre></div>
</div>
<p>马上可以看到一些不同点。有些是由于BLAT使用PSL格式储存它的信息，稍后会看
到。其余是由于BLAST和BLAT搜索的程序和数据库之间明显的差异造成的：</p>
<ul class="simple">
<li>程序名称和版本。 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 知道程序是BLAST，但是在输出文件中没
有信息显示程序版本，所以默认是 ‘&lt;unknown version&gt;’。</li>
<li>query的ID，描述和序列的长度。注意，这些细节和BLAST的细节只有细小的差别，
ID是 ‘mystery_seq’ 而不是42991，缺少描述，但是序列长度仍是61。这
实际上是文件格式本身导致的差异。BLAST有时创建自己的query ID并且用你的原
始ID作为序列描述。</li>
<li>目标数据库是未知的，因为BLAT输出文件没提到相关信息。</li>
<li>最后，hit列表完全不同。这里，我们的查询序列只命中到 ‘chr19’ 数据库条
目，但是我们可以看到它含有17个HSP区域。这并不让人诧异，考虑到我们
使用的是不同的程序，并且这些程序都有自己的数据库。</li>
</ul>
<p>所有通过调用 <tt class="docutils literal"><span class="pre">print</span></tt> 方法看到的信息都可以单独地用Python的对象属性获得（又叫点标记法）。同样还可以用相同的方法获得其他格式特有的属性。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">blast_qresult</span><span class="o">.</span><span class="n">program</span><span class="p">,</span> <span class="n">blast_qresult</span><span class="o">.</span><span class="n">version</span><span class="p">)</span>
<span class="go">blastn 2.2.27+</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">blat_qresult</span><span class="o">.</span><span class="n">program</span><span class="p">,</span> <span class="n">blat_qresult</span><span class="o">.</span><span class="n">version</span><span class="p">)</span>
<span class="go">blat &lt;unknown version&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blast_qresult</span><span class="o">.</span><span class="n">param_evalue_threshold</span>    <span class="c"># blast-xml specific</span>
<span class="go">10.0</span>
</pre></div>
</div>
<p>想获得一个可访问属性的完整列表，可以查询每个格式特有的文档。这些是
<a class="reference external" href="http://biopython.org/DIST/docs/api/Bio.SearchIO.BlastIO-module.html">BLAST</a>
<a class="reference external" href="http://biopython.org/DIST/docs/api/Bio.SearchIO.BlatIO-module.html">BLAT</a>.</p>
<p>已经知道了在 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象上可以调用 <tt class="docutils literal"><span class="pre">print</span></tt> 方法，让我们研究的更深
一些。 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 到底是什么？就Python对象来说， <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 混合
了列表和字典的特性。换句话说，也就是一个包含了列表和字典功能的容器对象。</p>
<p>和列表以及字典一样， <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象是可迭代的。每次迭代返回一个hit
对象：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">blast_qresult</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">hit</span>
<span class="go">Hit(id=&#39;gi|262205317|ref|NR_030195.1|&#39;, query_id=&#39;42291&#39;, 1 hsps)</span>
<span class="go">Hit(id=&#39;gi|301171311|ref|NR_035856.1|&#39;, query_id=&#39;42291&#39;, 1 hsps)</span>
<span class="go">Hit(id=&#39;gi|270133242|ref|NR_032573.1|&#39;, query_id=&#39;42291&#39;, 1 hsps)</span>
<span class="go">Hit(id=&#39;gi|301171322|ref|NR_035857.1|&#39;, query_id=&#39;42291&#39;, 2 hsps)</span>
<span class="go">Hit(id=&#39;gi|301171267|ref|NR_035851.1|&#39;, query_id=&#39;42291&#39;, 1 hsps)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>要得到 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象有多少hit，可以简单调用Python的 <tt class="docutils literal"><span class="pre">len</span></tt> 方法：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">blast_qresult</span><span class="p">)</span>
<span class="go">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">blat_qresult</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>同列表类似，你可以用切片来获得 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象的hit：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blast_qresult</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>        <span class="c"># retrieves the top hit</span>
<span class="go">Hit(id=&#39;gi|262205317|ref|NR_030195.1|&#39;, query_id=&#39;42291&#39;, 1 hsps)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blast_qresult</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>       <span class="c"># retrieves the last hit</span>
<span class="go">Hit(id=&#39;gi|397513516|ref|XM_003827011.1|&#39;, query_id=&#39;42291&#39;, 1 hsps)</span>
</pre></div>
</div>
<p>要得到多个hit，你同样可以对 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象作切片。这种情况下，返回一个包含被切hit的新 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blast_slice</span> <span class="o">=</span> <span class="n">blast_qresult</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>     <span class="c"># slices the first three hits</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">blast_slice</span>
<span class="go">Program: blastn (2.2.27+)</span>
<span class="go">  Query: 42291 (61)</span>
<span class="go">         mystery_seq</span>
<span class="go"> Target: refseq_rna</span>
<span class="go">   Hits: ----  -----  ----------------------------------------------------------</span>
<span class="go">            #  # HSP  ID + description</span>
<span class="go">         ----  -----  ----------------------------------------------------------</span>
<span class="go">            0      1  gi|262205317|ref|NR_030195.1|  Homo sapiens microRNA 52...</span>
<span class="go">            1      1  gi|301171311|ref|NR_035856.1|  Pan troglodytes microRNA...</span>
<span class="go">            2      1  gi|270133242|ref|NR_032573.1|  Macaca mulatta microRNA ...</span>
</pre></div>
</div>
<p>同字典类似，可以通过ID获取hit。如果你知道一个特定的hit ID存在于一个搜索结果中时，特别有用：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blast_qresult</span><span class="p">[</span><span class="s">&#39;gi|262205317|ref|NR_030195.1|&#39;</span><span class="p">]</span>
<span class="go">Hit(id=&#39;gi|262205317|ref|NR_030195.1|&#39;, query_id=&#39;42291&#39;, 1 hsps)</span>
</pre></div>
</div>
<p>你可以用 <tt class="docutils literal"><span class="pre">hits</span></tt> 方法获得完整的 <tt class="docutils literal"><span class="pre">Hit</span></tt> 对象，也可以用 <tt class="docutils literal"><span class="pre">hit_keys</span></tt> 方法获得完整的 <tt class="docutils literal"><span class="pre">Hit</span></tt> ID：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blast_qresult</span><span class="o">.</span><span class="n">hits</span>
<span class="go">[...]       # list of all hits</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blast_qresult</span><span class="o">.</span><span class="n">hit_keys</span>
<span class="go">[...]       # list of all hit IDs</span>
</pre></div>
</div>
<p>如果你想确定一个特定的hit是否存在于查询结果中该怎么做呢？可以用 <tt class="docutils literal"><span class="pre">in</span></tt> 关键字作一个简单的成员检验：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;gi|262205317|ref|NR_030195.1|&#39;</span> <span class="ow">in</span> <span class="n">blast_qresult</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;gi|262205317|ref|NR_030194.1|&#39;</span> <span class="ow">in</span> <span class="n">blast_qresult</span>
<span class="go">False</span>
</pre></div>
</div>
<p>有时候，只知道一个hit是否存在是不够的，你可能也会想知道hit的排名。 <tt class="docutils literal"><span class="pre">index</span></tt> 方法可以帮助你：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blast_qresult</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;gi|301171437|ref|NR_035870.1|&#39;</span><span class="p">)</span>
<span class="go">22</span>
</pre></div>
</div>
<p>记住，我们用的是Python风格的索引，是从0开始。这代表hit的排名是23而不是22。</p>
<p>同样，注意你看的hit排名是基于原始搜索输出文件的本来顺序。不同的搜索工具可
能会基于不同的标准排列hit。</p>
<p>如果原本的hit排序不合你意，可以用 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象的 <tt class="docutils literal"><span class="pre">sort</span></tt> 方法。
它和Python的 <tt class="docutils literal"><span class="pre">list.sort</span></tt> 方法很相似，只是有个是否创建一个新的排序后的
<tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象的选项。</p>
<p>这里有个用 <tt class="docutils literal"><span class="pre">QueryResult.sort</span></tt> 方法对hit排序的例子，这个方法基于每个hit
的完整序列长度。对于这个特殊的排序，我们设置 <tt class="docutils literal"><span class="pre">in_place</span></tt> 参数等于 <tt class="docutils literal"><span class="pre">False</span></tt> ，
这样排序方法会返回一个新的 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象，而原来的对象是未排序的。
我们同样可以设置 <tt class="docutils literal"><span class="pre">reverse</span></tt> 参数等于 `` True `` 以递减排序。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">blast_qresult</span><span class="p">[:</span><span class="mi">5</span><span class="p">]:</span>   <span class="c"># id and sequence length of the first five hits</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">hit</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">hit</span><span class="o">.</span><span class="n">seq_len</span>
<span class="gp">...</span>
<span class="go">gi|262205317|ref|NR_030195.1| 61</span>
<span class="go">gi|301171311|ref|NR_035856.1| 60</span>
<span class="go">gi|270133242|ref|NR_032573.1| 85</span>
<span class="go">gi|301171322|ref|NR_035857.1| 86</span>
<span class="go">gi|301171267|ref|NR_035851.1| 80</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">sort_key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">hit</span><span class="p">:</span> <span class="n">hit</span><span class="o">.</span><span class="n">seq_len</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sorted_qresult</span> <span class="o">=</span> <span class="n">blast_qresult</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">sort_key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">sorted_qresult</span><span class="p">[:</span><span class="mi">5</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">hit</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">hit</span><span class="o">.</span><span class="n">seq_len</span>
<span class="gp">...</span>
<span class="go">gi|397513516|ref|XM_003827011.1| 6002</span>
<span class="go">gi|390332045|ref|XM_776818.2| 4082</span>
<span class="go">gi|390332043|ref|XM_003723358.1| 4079</span>
<span class="go">gi|356517317|ref|XM_003527287.1| 3251</span>
<span class="go">gi|356543101|ref|XM_003539954.1| 2936</span>
</pre></div>
</div>
<p>有 <tt class="docutils literal"><span class="pre">in_place</span></tt> 参数的好处是可以保留原本的顺序，后面会用到。注意这不是 <tt class="docutils literal"><span class="pre">QueryResult.sort</span></tt> 的默认行为，需要我们明确地设置 <tt class="docutils literal"><span class="pre">in_place</span></tt> 为 <tt class="docutils literal"><span class="pre">True</span></tt> 。</p>
<p>现在，你已经知道使用 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象。但是，在我们学习 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt>
模块下个对象前，先了解下可以让 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象更易使用的两个方法：
<tt class="docutils literal"><span class="pre">filter</span></tt> 和 <tt class="docutils literal"><span class="pre">map</span></tt> 方法。</p>
<p>如果你对Python的列表推导式、generator表达式或内建的 <tt class="docutils literal"><span class="pre">filter</span></tt> 和 <tt class="docutils literal"><span class="pre">map</span></tt>
很熟悉，就知道（不知道就是看看吧!)它们在处理list-like的对象时有多有用。
你可以用这些内建的方法来操作 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象，但是这只对正常list有效，并且可操作性也会受到限制。</p>
<p>这就是为什么 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象提供自己特有的 <tt class="docutils literal"><span class="pre">filter</span></tt> 和 <tt class="docutils literal"><span class="pre">map</span></tt>
方法。对于 <tt class="docutils literal"><span class="pre">filter</span></tt> 有相似的 <tt class="docutils literal"><span class="pre">hit_filter</span></tt> 和 <tt class="docutils literal"><span class="pre">hsp_filter</span></tt> 方法，
从名称就可以看出，这些方法过滤 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象的 <tt class="docutils literal"><span class="pre">Hit</span></tt> 对象或者
<tt class="docutils literal"><span class="pre">HSP</span></tt> 对象。同样的，对于 <tt class="docutils literal"><span class="pre">map</span></tt> ， <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象同样提供相似
的  <tt class="docutils literal"><span class="pre">hit_map</span></tt> 和 <tt class="docutils literal"><span class="pre">hsp_map</span></tt> 方法。这些方法分别应用于 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象 <tt class="docutils literal"><span class="pre">hit</span></tt> 或者 <tt class="docutils literal"><span class="pre">HSP</span></tt> 对象。</p>
<p>让我们来看看这些方法的功能，从 <tt class="docutils literal"><span class="pre">hit_filter</span></tt> 开始。这个方法接受一个回调
函数，这个函数检验给定的 <tt class="docutils literal"><span class="pre">Hit</span></tt> 是否符合你设定的条件。换句话说，这个方法
必须接受一个单独 <tt class="docutils literal"><span class="pre">Hit</span></tt> 对象作为参数并且返回  <tt class="docutils literal"><span class="pre">True</span></tt> 或 <tt class="docutils literal"><span class="pre">False</span></tt> 。</p>
<p>这里有个用 <tt class="docutils literal"><span class="pre">hit_filter</span></tt> 筛选出只有一个HSP的 <tt class="docutils literal"><span class="pre">Hit</span></tt> 对象的例子：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">filter_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">hit</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">hit</span><span class="o">.</span><span class="n">hsps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>     <span class="c"># the callback function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">blast_qresult</span><span class="p">)</span>      <span class="c"># no. of hits before filtering</span>
<span class="go">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered_qresult</span> <span class="o">=</span> <span class="n">blast_qresult</span><span class="o">.</span><span class="n">hit_filter</span><span class="p">(</span><span class="n">filter_func</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_qresult</span><span class="p">)</span>   <span class="c"># no. of hits after filtering</span>
<span class="go">37</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">filtered_qresult</span><span class="p">[:</span><span class="mi">5</span><span class="p">]:</span>    <span class="c"># quick check for the hit lengths</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">hit</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hit</span><span class="o">.</span><span class="n">hsps</span><span class="p">)</span>
<span class="go">gi|301171322|ref|NR_035857.1| 2</span>
<span class="go">gi|262205330|ref|NR_030198.1| 2</span>
<span class="go">gi|301171447|ref|NR_035871.1| 2</span>
<span class="go">gi|262205298|ref|NR_030190.1| 2</span>
<span class="go">gi|270132717|ref|NR_032716.1| 2</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">hsp_filter</span></tt> 和 <tt class="docutils literal"><span class="pre">hit_filter</span></tt> 功能相同，只是它过滤每个hit中的 <tt class="docutils literal"><span class="pre">HSP</span></tt> 对象，
而不是 <tt class="docutils literal"><span class="pre">Hit</span></tt> 。</p>
<p>对于 <tt class="docutils literal"><span class="pre">map</span></tt> 方法，同样接受一个回调函数作为参数。但是回调函数返回修改过的 <tt class="docutils literal"><span class="pre">Hit</span></tt> 或 <tt class="docutils literal"><span class="pre">HSP</span></tt> 对象（取决于你是否使用 <tt class="docutils literal"><span class="pre">hit_map</span></tt> 或 <tt class="docutils literal"><span class="pre">hsp_map</span></tt> 方法），
而不是返回 <tt class="docutils literal"><span class="pre">True</span></tt> 或 <tt class="docutils literal"><span class="pre">False</span></tt>。</p>
<p>来看一个用 <tt class="docutils literal"><span class="pre">hit_map</span></tt> 方法来重命名hit ID的例子：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">map_func</span><span class="p">(</span><span class="n">hit</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">hit</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">hit</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;|&#39;</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>   <span class="c"># renames &#39;gi|301171322|ref|NR_035857.1|&#39; to &#39;NR_035857.1&#39;</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">hit</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mapped_qresult</span> <span class="o">=</span> <span class="n">blast_qresult</span><span class="o">.</span><span class="n">hit_map</span><span class="p">(</span><span class="n">map_func</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">hit</span> <span class="ow">in</span> <span class="n">mapped_qresult</span><span class="p">[:</span><span class="mi">5</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">hit</span><span class="o">.</span><span class="n">id</span>
<span class="go">NR_030195.1</span>
<span class="go">NR_035856.1</span>
<span class="go">NR_032573.1</span>
<span class="go">NR_035857.1</span>
<span class="go">NR_035851.1</span>
</pre></div>
</div>
<p>同样的， <tt class="docutils literal"><span class="pre">hsp_map</span></tt> 和 <tt class="docutils literal"><span class="pre">hit_map</span></tt> 作用相似, 但是作用于 <tt class="docutils literal"><span class="pre">HSP</span></tt> 对象而不是 <tt class="docutils literal"><span class="pre">Hit</span></tt> 对象。</p>
</div>
<div class="section" id="hit">
<h3>8.1.2  Hit<a class="headerlink" href="#hit" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">Hit</span></tt> 对象代表从单个数据库获得所有查询结果。在 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 对象等级中是二级容器。它们被包含在 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象中，同时它们又包含 <tt class="docutils literal"><span class="pre">HSP</span></tt> 对象。</p>
<p>看看它们是什么样的，从我们的BLAST搜索开始：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SearchIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blast_qresult</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s">&#39;my_blast.xml&#39;</span><span class="p">,</span> <span class="s">&#39;blast-xml&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blast_hit</span> <span class="o">=</span> <span class="n">blast_qresult</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>    <span class="c"># fourth hit from the query result</span>
</pre></div>
</div>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">blast_hit</span>
<span class="go">Query: 42291</span>
<span class="go">       mystery_seq</span>
<span class="go">  Hit: gi|301171322|ref|NR_035857.1| (86)</span>
<span class="go">       Pan troglodytes microRNA mir-520c (MIR520C), microRNA</span>
<span class="go"> HSPs: ----  --------  ---------  ------  ---------------  ---------------------</span>
<span class="go">          #   E-value  Bit score    Span      Query range              Hit range</span>
<span class="go">       ----  --------  ---------  ------  ---------------  ---------------------</span>
<span class="go">          0   8.9e-20     100.47      60           [1:61]                [13:73]</span>
<span class="go">          1   3.3e-06      55.39      60           [0:60]                [13:73]</span>
</pre></div>
</div>
<p>可以看到我们获得了必要的信息：</p>
<ul class="simple">
<li>query的ID和描述信息。一个hit总是和一个query绑定，所以我们同样希望记录原始
query。这些值可以通过 <tt class="docutils literal"><span class="pre">query_id</span></tt> 和  <tt class="docutils literal"><span class="pre">query_description</span></tt> 属性从hit
中获取。</li>
<li>我们同样得到了hit的ID、描述和序列全长。它们可以分别通过 <tt class="docutils literal"><span class="pre">id</span></tt>，
<tt class="docutils literal"><span class="pre">description</span></tt>，和 <tt class="docutils literal"><span class="pre">seq_len</span></tt> 获取。</li>
<li>最后，有一个hit含有的HSP的简短信息表。在每行中，HSP重要信息被
列出来：HSP索引，e值，得分，长度（包括gap），query坐标和hit坐标。</li>
</ul>
<p>现在，和BLAT结果作对比。记住，在BLAT搜索结果中，我们发现有一个含有17HSP的hit。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blat_qresult</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s">&#39;my_blat.psl&#39;</span><span class="p">,</span> <span class="s">&#39;blat-psl&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hit</span> <span class="o">=</span> <span class="n">blat_qresult</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>      <span class="c"># the only hit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">blat_hit</span>
<span class="go">Query: mystery_seq</span>
<span class="go">       &lt;unknown description&gt;</span>
<span class="go">  Hit: chr19 (59128983)</span>
<span class="go">       &lt;unknown description&gt;</span>
<span class="go"> HSPs: ----  --------  ---------  ------  ---------------  ---------------------</span>
<span class="go">          #   E-value  Bit score    Span      Query range              Hit range</span>
<span class="go">       ----  --------  ---------  ------  ---------------  ---------------------</span>
<span class="go">          0         ?          ?       ?           [0:61]    [54204480:54204541]</span>
<span class="go">          1         ?          ?       ?           [0:61]    [54233104:54264463]</span>
<span class="go">          2         ?          ?       ?           [0:61]    [54254477:54260071]</span>
<span class="go">          3         ?          ?       ?           [1:61]    [54210720:54210780]</span>
<span class="go">          4         ?          ?       ?           [0:60]    [54198476:54198536]</span>
<span class="go">          5         ?          ?       ?           [0:61]    [54265610:54265671]</span>
<span class="go">          6         ?          ?       ?           [0:61]    [54238143:54240175]</span>
<span class="go">          7         ?          ?       ?           [0:60]    [54189735:54189795]</span>
<span class="go">          8         ?          ?       ?           [0:61]    [54185425:54185486]</span>
<span class="go">          9         ?          ?       ?           [0:60]    [54197657:54197717]</span>
<span class="go">         10         ?          ?       ?           [0:61]    [54255662:54255723]</span>
<span class="go">         11         ?          ?       ?           [0:61]    [54201651:54201712]</span>
<span class="go">         12         ?          ?       ?           [8:60]    [54206009:54206061]</span>
<span class="go">         13         ?          ?       ?          [10:61]    [54178987:54179038]</span>
<span class="go">         14         ?          ?       ?           [8:61]    [54212018:54212071]</span>
<span class="go">         15         ?          ?       ?           [8:51]    [54234278:54234321]</span>
<span class="go">         16         ?          ?       ?           [8:61]    [54238143:54238196]</span>
</pre></div>
</div>
<p>我们得到了和前面看到的BLAST hit详细程度相似的结果。但是有些不同点需要解释：</p>
<ul class="simple">
<li>e-value和bit score列的值。因为BLAT HSP没有e-values和bit scores，默
认显示‘?’.</li>
<li>span列是怎么回事呢？span值本来是显示完整的比对长度，包含所有的残基和
gap。但是PSL格式目前还不支持这些信息并且 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 也不打算去猜它到底是多少，所有我们得到了和e-value以及bit score列相同的 ‘?’。</li>
</ul>
<p>就Python对象来说， <tt class="docutils literal"><span class="pre">Hit</span></tt> 和列表行为最相似，但是额外含有 <tt class="docutils literal"><span class="pre">HSP</span></tt> 。如果
你对列表熟悉，在使用 <tt class="docutils literal"><span class="pre">Hit</span></tt> 对象是不会遇到困难。</p>
<p>和列表一样， <tt class="docutils literal"><span class="pre">Hit</span></tt> 对象是可迭代的，并且每次迭代返回一个 <tt class="docutils literal"><span class="pre">HSP</span></tt> 对象：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">hsp</span> <span class="ow">in</span> <span class="n">blast_hit</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">hsp</span>
<span class="go">HSP(hit_id=&#39;gi|301171322|ref|NR_035857.1|&#39;, query_id=&#39;42291&#39;, 1 fragments)</span>
<span class="go">HSP(hit_id=&#39;gi|301171322|ref|NR_035857.1|&#39;, query_id=&#39;42291&#39;, 1 fragments)</span>
</pre></div>
</div>
<p>你可以对 <tt class="docutils literal"><span class="pre">Hit</span></tt> 对象调用 <tt class="docutils literal"><span class="pre">len</span></tt> 方法查看它含有多少个 <tt class="docutils literal"><span class="pre">HSP</span></tt> 对象：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">blast_hit</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">blat_hit</span><span class="p">)</span>
<span class="go">17</span>
</pre></div>
</div>
<p>你可以对 <tt class="docutils literal"><span class="pre">Hit</span></tt> 对象作切片取得单个或多个 <tt class="docutils literal"><span class="pre">HSP</span></tt> 对象，和 <tt class="docutils literal"><span class="pre">QueryResult</span></tt>
一样，如果切取多个 <tt class="docutils literal"><span class="pre">HSP</span></tt>  ，会返回包含被切片 <tt class="docutils literal"><span class="pre">HSP</span></tt>  的一个新 <tt class="docutils literal"><span class="pre">Hit</span></tt> 对象。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                 <span class="c"># retrieve single items</span>
<span class="go">HSP(hit_id=&#39;chr19&#39;, query_id=&#39;mystery_seq&#39;, 1 fragments)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sliced_hit</span> <span class="o">=</span> <span class="n">blat_hit</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>  <span class="c"># retrieve multiple items</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">sliced_hit</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sliced_hit</span>
<span class="go">Query: mystery_seq</span>
<span class="go">       &lt;unknown description&gt;</span>
<span class="go">  Hit: chr19 (59128983)</span>
<span class="go">       &lt;unknown description&gt;</span>
<span class="go"> HSPs: ----  --------  ---------  ------  ---------------  ---------------------</span>
<span class="go">          #   E-value  Bit score    Span      Query range              Hit range</span>
<span class="go">       ----  --------  ---------  ------  ---------------  ---------------------</span>
<span class="go">          0         ?          ?       ?           [0:60]    [54198476:54198536]</span>
<span class="go">          1         ?          ?       ?           [0:61]    [54265610:54265671]</span>
<span class="go">          2         ?          ?       ?           [0:61]    [54238143:54240175]</span>
<span class="go">          3         ?          ?       ?           [0:60]    [54189735:54189795]</span>
<span class="go">          4         ?          ?       ?           [0:61]    [54185425:54185486]</span>
</pre></div>
</div>
<p>你同样可以对一个 <tt class="docutils literal"><span class="pre">Hit</span></tt> 里的 <tt class="docutils literal"><span class="pre">HSP</span></tt>  排序，和你在 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象
中看到的方法一样。</p>
<p>最后，同样可以对 <tt class="docutils literal"><span class="pre">Hit</span></tt> 对象使用 <tt class="docutils literal"><span class="pre">filter</span></tt> 和 <tt class="docutils literal"><span class="pre">map</span></tt> 方法。和 <tt class="docutils literal"><span class="pre">QueryResult</span></tt>
不同， <tt class="docutils literal"><span class="pre">Hit</span></tt> 对象只有一种 <tt class="docutils literal"><span class="pre">filter</span></tt> (<tt class="docutils literal"><span class="pre">Hit.filter</span></tt>) 和一种 <tt class="docutils literal"><span class="pre">map</span></tt> (<tt class="docutils literal"><span class="pre">Hit.map</span></tt>)。</p>
</div>
<div class="section" id="hsp">
<h3>8.1.3  HSP<a class="headerlink" href="#hsp" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">HSP</span></tt> (高分片段)代表hit序列中的一个区域，该区域包含对于查询序列有意义的
比对。它包含了你的查询序列和一个数据库条目之间精确的匹配。由于匹配取决于
序列搜索工具的算法， <tt class="docutils literal"><span class="pre">HSP</span></tt>  含有大部分统计信息，这些统计是由搜索工具计
算得到的。这使得不同搜索工具的 <tt class="docutils literal"><span class="pre">HSP</span></tt>  对象之间的差异和你在 <tt class="docutils literal"><span class="pre">QueryResult</span></tt>
以及 <tt class="docutils literal"><span class="pre">Hit</span></tt> 对象看到的差异更加明显。</p>
<p>我们来看看BLAST和BLAT搜索的例子。先看BLAST HSP：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SearchIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blast_qresult</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s">&#39;my_blast.xml&#39;</span><span class="p">,</span> <span class="s">&#39;blast-xml&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blast_hsp</span> <span class="o">=</span> <span class="n">blast_qresult</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>    <span class="c"># first hit, first hsp</span>
</pre></div>
</div>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">blast_hsp</span>
<span class="go">      Query: 42291 mystery_seq</span>
<span class="go">        Hit: gi|262205317|ref|NR_030195.1| Homo sapiens microRNA 520b (MIR520...</span>
<span class="go">Query range: [0:61] (1)</span>
<span class="go">  Hit range: [0:61] (1)</span>
<span class="go">Quick stats: evalue 4.9e-23; bitscore 111.29</span>
<span class="go">  Fragments: 1 (61 columns)</span>
<span class="go">     Query - CCCTCTACAGGGAAGCGCTTTCTGTTGTCTGAAAGAAAAGAAAGTGCTTCCTTTTAGAGGG</span>
<span class="go">             |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||</span>
<span class="go">       Hit - CCCTCTACAGGGAAGCGCTTTCTGTTGTCTGAAAGAAAAGAAAGTGCTTCCTTTTAGAGGG</span>
</pre></div>
</div>
<p>和 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 以及 <tt class="docutils literal"><span class="pre">Hit</span></tt> 类似，调用 <tt class="docutils literal"><span class="pre">HSP</span></tt>  的 <tt class="docutils literal"><span class="pre">print</span></tt> 方法,
显示细节：</p>
<ul class="simple">
<li>有query和hit的ID以及描述。我们需要这些来识别我们的 <tt class="docutils literal"><span class="pre">HSP</span></tt>  。</li>
<li>我们同样得到了query和hit序列的匹配范围。这里用的的切片标志着范围的表示
是使用Python的索引风格（从0开始，半开区间）。圆括号里的数字表示正负链。
这里，两条序列都是正链。</li>
<li>还有一些简短统计：e-value和bitscore。</li>
<li>还有一些HSP片段的信息。现在可以忽略，稍后会解释。</li>
<li>最后，还有query和hit的比对。</li>
</ul>
<p>这些信息可以用点标记从它们本身获得，和 <tt class="docutils literal"><span class="pre">Hit</span></tt> 以及 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 相同：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blast_hsp</span><span class="o">.</span><span class="n">query_range</span>
<span class="go">(0, 61)</span>
</pre></div>
</div>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blast_hsp</span><span class="o">.</span><span class="n">evalue</span>
<span class="go">4.91307e-23</span>
</pre></div>
</div>
<p>它们并不是仅有的属性， <tt class="docutils literal"><span class="pre">HSP</span></tt>  对象有一系列的属性，使得获得它们的具体信
息更加容易。下面是一些例子：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blast_hsp</span><span class="o">.</span><span class="n">hit_start</span>         <span class="c"># start coordinate of the hit sequence</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blast_hsp</span><span class="o">.</span><span class="n">query_span</span>        <span class="c"># how many residues in the query sequence</span>
<span class="go">61</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blast_hsp</span><span class="o">.</span><span class="n">aln_span</span>          <span class="c"># how long the alignment is</span>
<span class="go">61</span>
</pre></div>
</div>
<p>查看 <tt class="docutils literal"><span class="pre">HSP</span></tt>
<a class="reference external" href="http://biopython.org/DIST/docs/api/Bio.SearchIO._model.hsp-module.html">文档</a>
获取完整的属性列表。</p>
<p>不仅如此，每个搜索工具通常会对它的 <tt class="docutils literal"><span class="pre">HSP</span></tt>  对象作统计学或其他细节计算。例如，一个
XML BLAST搜索同样输出gap以及相同的残基数量。这些属性可以像这样被获取：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blast_hsp</span><span class="o">.</span><span class="n">gap_num</span>       <span class="c"># number of gaps</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blast_hsp</span><span class="o">.</span><span class="n">ident_num</span>     <span class="c"># number of identical residues</span>
<span class="go">61</span>
</pre></div>
</div>
<p>这些细节是格式特异的；它们可能不会出现在其他的格式中。要知道哪些细节在给
定的序列搜索工具中是存在的，你应该查看那种格式的在 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 中的
文档。或者可以用 <tt class="docutils literal"><span class="pre">.__dict__.keys()</span></tt> 获得快速列表：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blast_hsp</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&#39;bitscore&#39;, &#39;evalue&#39;, &#39;ident_num&#39;, &#39;gap_num&#39;, &#39;bitscore_raw&#39;, &#39;pos_num&#39;, &#39;_items&#39;]</span>
</pre></div>
</div>
<p>最后，你可能已经注意到了，我们HSP的 <tt class="docutils literal"><span class="pre">query</span></tt> 和 <tt class="docutils literal"><span class="pre">hit</span></tt> 属性不只是规律字符串：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blast_hsp</span><span class="o">.</span><span class="n">query</span>
<span class="go">SeqRecord(seq=Seq(&#39;CCCTCTACAGGGAAGCGCTTTCTGTTGTCTGAAAGAAAAGAAAGTGCTTCCTTT...GGG&#39;, DNAAlphabet()), id=&#39;42291&#39;, name=&#39;aligned query sequence&#39;, description=&#39;mystery_seq&#39;, dbxrefs=[])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blast_hsp</span><span class="o">.</span><span class="n">hit</span>
<span class="go">SeqRecord(seq=Seq(&#39;CCCTCTACAGGGAAGCGCTTTCTGTTGTCTGAAAGAAAAGAAAGTGCTTCCTTT...GGG&#39;, DNAAlphabet()), id=&#39;gi|262205317|ref|NR_030195.1|&#39;, name=&#39;aligned hit sequence&#39;, description=&#39;Homo sapiens microRNA 520b (MIR520B), microRNA&#39;, dbxrefs=[])</span>
</pre></div>
</div>
<p>它们是你已经在第 <a class="reference external" href="#chapter:SeqRecord">4</a> 章看到过的 <tt class="docutils literal"><span class="pre">SeqRecord</span></tt> 对象！
意味着你可以对 <tt class="docutils literal"><span class="pre">SeqRecord</span></tt> 对象做的各种有趣的事同样适用于 <tt class="docutils literal"><span class="pre">HSP.query</span></tt> 和 <tt class="docutils literal"><span class="pre">HSP.hit</span></tt> 对象。</p>
<p>现在 <tt class="docutils literal"><span class="pre">HSP</span></tt>  对象有个 <tt class="docutils literal"><span class="pre">alignment</span></tt> 属性（一个 <tt class="docutils literal"><span class="pre">MultipleSeqAlignment</span></tt>
对象）应该不会让你感到惊讶：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">blast_hsp</span><span class="o">.</span><span class="n">aln</span>
<span class="go">DNAAlphabet() alignment with 2 rows and 61 columns</span>
<span class="go">CCCTCTACAGGGAAGCGCTTTCTGTTGTCTGAAAGAAAAGAAAG...GGG 42291</span>
<span class="go">CCCTCTACAGGGAAGCGCTTTCTGTTGTCTGAAAGAAAAGAAAG...GGG gi|262205317|ref|NR_030195.1|</span>
</pre></div>
</div>
<p>探索完BLAST HSP对象，让我们看看来自BLAT结果的不一样的HSP。我们将对它调用 <tt class="docutils literal"><span class="pre">print</span></tt> 方法：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blat_qresult</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s">&#39;my_blat.psl&#39;</span><span class="p">,</span> <span class="s">&#39;blat-psl&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hsp</span> <span class="o">=</span> <span class="n">blat_qresult</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>       <span class="c"># first hit, first hsp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">blat_hsp</span>
<span class="go">      Query: mystery_seq &lt;unknown description&gt;</span>
<span class="go">        Hit: chr19 &lt;unknown description&gt;</span>
<span class="go">Query range: [0:61] (1)</span>
<span class="go">  Hit range: [54204480:54204541] (1)</span>
<span class="go">Quick stats: evalue ?; bitscore ?</span>
<span class="go">  Fragments: 1 (? columns)</span>
</pre></div>
</div>
<p>一些输出你应该已经猜到了。我们得到了查询序列、hit ID、描述以及序列坐标。
evalue和bitscore的值是 ‘?’ ，因为BLAT HSP并没有这些属性。但是最大的不同
是你看不到任何的序列比对展示。如果你看的更仔细，PSL格式本身并没有任何的
hit和query序列，所以 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 不会创建任何序列或者比对对象。如果
你尝试获取 <tt class="docutils literal"><span class="pre">HSP.query</span></tt> ，<tt class="docutils literal"><span class="pre">HSP.hit</span></tt> ， 或者 <tt class="docutils literal"><span class="pre">HSP.aln</span></tt> 属性会怎么样
呢？你会得到这些属性的默认值 <tt class="docutils literal"><span class="pre">None</span></tt> ：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hsp</span><span class="o">.</span><span class="n">hit</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hsp</span><span class="o">.</span><span class="n">query</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hsp</span><span class="o">.</span><span class="n">aln</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
<p>这并不影响其他的属性。例如，你仍然可以获取query和hit比对的长度。尽管不显
示任何的属性，但是PSL格式还是有这些信息的，所以 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 可以抽
提出这些信息。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hsp</span><span class="o">.</span><span class="n">query_span</span>     <span class="c"># length of query match</span>
<span class="go">61</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hsp</span><span class="o">.</span><span class="n">hit_span</span>       <span class="c"># length of hit match</span>
<span class="go">61</span>
</pre></div>
</div>
<p>其他格式特异的属性同样被展示出来：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hsp</span><span class="o">.</span><span class="n">score</span>          <span class="c"># PSL score</span>
<span class="go">61</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hsp</span><span class="o">.</span><span class="n">mismatch_num</span>   <span class="c"># the mismatch column</span>
<span class="go">0</span>
</pre></div>
</div>
<p>到目前为止，一切还不错？当你看到BLAT结果中不同的HSP时，事情变得更有趣了。
你可能会回想起在BLAT搜索中，有时我们把结果分成 ‘blocks’ 。这些区块是必需比对片段，可能会有些内含子在它们之间。</p>
<p>让我们看看 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 怎么处理包含多个区块的BLAT HSP：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hsp2</span> <span class="o">=</span> <span class="n">blat_qresult</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>      <span class="c"># first hit, second hsp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">blat_hsp2</span>
<span class="go">      Query: mystery_seq &lt;unknown description&gt;</span>
<span class="go">        Hit: chr19 &lt;unknown description&gt;</span>
<span class="go">Query range: [0:61] (1)</span>
<span class="go">  Hit range: [54233104:54264463] (1)</span>
<span class="go">Quick stats: evalue ?; bitscore ?</span>
<span class="go">  Fragments: ---  --------------  ----------------------  ----------------------</span>
<span class="go">               #            Span             Query range               Hit range</span>
<span class="go">             ---  --------------  ----------------------  ----------------------</span>
<span class="go">               0               ?                  [0:18]     [54233104:54233122]</span>
<span class="go">               1               ?                 [18:61]     [54264420:54264463]</span>
</pre></div>
</div>
<p>怎么回事？我们仍然得到了一些必要的信息：ID，描述信息，坐标和快速统计，和
你前面看到的一样。但是片段信息完全不同。我们得到了有两行数据的表格，而不是显示 ‘Fragment: 1’。</p>
<p>这就是 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 处理含有多片段HSP的方式。和前面提到的一样，一个
HSP比对可能会被内含子分成多个片段。内含子不是query-hit匹配的一部分，所以
它们不能被当成query或hit序列的一部分。但是，它们确实影响我们处理序列坐标，
所以我们不能忽视。</p>
<p>看看上面的HSP的hit坐标。在 <tt class="docutils literal"><span class="pre">Hit</span> <span class="pre">range</span></tt> 区域，我们看到坐标是
<tt class="docutils literal"><span class="pre">[54233104:54264463]</span></tt>。但是看看表格中的行，我们发现不是坐标跨度的所有区域
都能匹配我们的query。特殊的是，间断区域从 <tt class="docutils literal"><span class="pre">54233122</span></tt> 到 <tt class="docutils literal"><span class="pre">54264420</span></tt> 。</p>
<p>你可能会问，为什么query坐标好像是邻近的?这是很好的。在这个例子中，query是连续的（无间断区域），但是hit却不是。</p>
<p>所有的这些属性都是可以直接从HSP获取的，通过这样的方式：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hsp2</span><span class="o">.</span><span class="n">hit_range</span>         <span class="c"># hit start and end coordinates of the entire HSP</span>
<span class="go">(54233104, 54264463)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hsp2</span><span class="o">.</span><span class="n">hit_range_all</span>     <span class="c"># hit start and end coordinates of each fragment</span>
<span class="go">[(54233104, 54233122), (54264420, 54264463)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hsp2</span><span class="o">.</span><span class="n">hit_span</span>          <span class="c"># hit span of the entire HSP</span>
<span class="go">31359</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hsp2</span><span class="o">.</span><span class="n">hit_span_all</span>      <span class="c"># hit span of each fragment</span>
<span class="go">[18, 43]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hsp2</span><span class="o">.</span><span class="n">hit_inter_ranges</span>  <span class="c"># start and end coordinates of intervening regions in the hit sequence</span>
<span class="go">[(54233122, 54264420)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hsp2</span><span class="o">.</span><span class="n">hit_inter_spans</span>   <span class="c"># span of intervening regions in the hit sequence</span>
<span class="go">[31298]</span>
</pre></div>
</div>
<p>这些属性中大多数都不能简单地从PSL文件获得，但是当你分析PSL文件时，
<tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 会动态地帮你计算。它需要的只是每个片段的开始和结束坐标。</p>
<p><tt class="docutils literal"><span class="pre">query</span></tt>， <tt class="docutils literal"><span class="pre">hit</span></tt>， 和 <tt class="docutils literal"><span class="pre">aln</span></tt> 属性又是什么情况？如果HSP含有多个片段，
你就不能使用这些属性，因为它们只取回单个 <tt class="docutils literal"><span class="pre">SeqRecord</span></tt> 或
<tt class="docutils literal"><span class="pre">MultipleSeqAlignment</span></tt> 对象。但是，你可以用相应的 <tt class="docutils literal"><span class="pre">*_all</span></tt> 方法：
<tt class="docutils literal"><span class="pre">query_all</span></tt>， <tt class="docutils literal"><span class="pre">hit_all</span></tt>， 和 <tt class="docutils literal"><span class="pre">aln_all</span></tt>。 这些属性会返回包含每个HSP
片段的 <tt class="docutils literal"><span class="pre">SeqRecord</span></tt> 或 <tt class="docutils literal"><span class="pre">MultipleSeqAlignment</span></tt> 对象的列表。还有其他相同
功能的属性，也就是只对只有一个片段的HSP有效。查看 <tt class="docutils literal"><span class="pre">HSP</span></tt>
<a class="reference external" href="http://biopython.org/DIST/docs/api/Bio.SearchIO._model.hsp-module.html">文档</a>
获得完整的列表。</p>
<p>最后，想要检查是否是多片段HSP，你可以用 <tt class="docutils literal"><span class="pre">is_fragmented</span></tt> 属性：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hsp2</span><span class="o">.</span><span class="n">is_fragmented</span>     <span class="c"># BLAT HSP with 2 fragments</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blat_hsp</span><span class="o">.</span><span class="n">is_fragmented</span>      <span class="c"># BLAT HSP from earlier, with one fragment</span>
<span class="go">False</span>
</pre></div>
</div>
<p>在进入下部分之前，你只需要了解我们可以对 <tt class="docutils literal"><span class="pre">HSP</span></tt> 对象使用切片，和
<tt class="docutils literal"><span class="pre">QueryResult</span></tt> 或 <tt class="docutils literal"><span class="pre">Hit</span></tt> 对象一样。当你使用切片的时候，会返回一个
<tt class="docutils literal"><span class="pre">HSPFragment</span></tt> 对象。</p>
</div>
<div class="section" id="id1">
<h3>8.1.4  HSP片段<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">HSPFragment</span></tt> 代表query和hit之间单个连续匹配。应该把它当作对象模型
和搜索结果的核心，因为它决定你的搜索是否有结果。</p>
<p>在多数情况下，你不必直接处理 <tt class="docutils literal"><span class="pre">HSPFragment</span></tt> 对象，因为没有那么多搜索工具
断裂它们的HSP。当你确实需要处理它们时，需要记住的是 <tt class="docutils literal"><span class="pre">HSPFragment</span></tt> 对象
要被写地尽量压缩。在多数情况下，它们仅仅包含直接与序列有关的属性：正负链，
阅读框，字母表，位置坐标，序列本身以及它们的ID和描述。</p>
<p>当你对 <tt class="docutils literal"><span class="pre">HSPFragment</span></tt> 对象调用 <tt class="docutils literal"><span class="pre">print</span></tt> 方法时，这些属性可以非常简单地显示
出来。这里有个从我们BLAST搜索得到的例子：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SearchIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blast_qresult</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s">&#39;my_blast.xml&#39;</span><span class="p">,</span> <span class="s">&#39;blast-xml&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blast_frag</span> <span class="o">=</span> <span class="n">blast_qresult</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>    <span class="c"># first hit, first hsp, first fragment</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">blast_frag</span>
<span class="go">      Query: 42291 mystery_seq</span>
<span class="go">        Hit: gi|262205317|ref|NR_030195.1| Homo sapiens microRNA 520b (MIR520...</span>
<span class="go">Query range: [0:61] (1)</span>
<span class="go">  Hit range: [0:61] (1)</span>
<span class="go">  Fragments: 1 (61 columns)</span>
<span class="go">     Query - CCCTCTACAGGGAAGCGCTTTCTGTTGTCTGAAAGAAAAGAAAGTGCTTCCTTTTAGAGGG</span>
<span class="go">             |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||</span>
<span class="go">       Hit - CCCTCTACAGGGAAGCGCTTTCTGTTGTCTGAAAGAAAAGAAAGTGCTTCCTTTTAGAGGG</span>
</pre></div>
</div>
<p>在这个水平上，BLAT和BLAST片段看起来非常相似，除了没有出现的query和hit序列：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blat_qresult</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s">&#39;my_blat.psl&#39;</span><span class="p">,</span> <span class="s">&#39;blat-psl&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blat_frag</span> <span class="o">=</span> <span class="n">blat_qresult</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>    <span class="c"># first hit, first hsp, first fragment</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">blat_frag</span>
<span class="go">      Query: mystery_seq &lt;unknown description&gt;</span>
<span class="go">        Hit: chr19 &lt;unknown description&gt;</span>
<span class="go">Query range: [0:61] (1)</span>
<span class="go">  Hit range: [54204480:54204541] (1)</span>
<span class="go">  Fragments: 1 (? columns)</span>
</pre></div>
</div>
<p>在所有情况下，这些属性都可以通过我们最爱的点标记访问。一些例子：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blast_frag</span><span class="o">.</span><span class="n">query_start</span>      <span class="c"># query start coordinate</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blast_frag</span><span class="o">.</span><span class="n">hit_strand</span>       <span class="c"># hit sequence strand</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blast_frag</span><span class="o">.</span><span class="n">hit</span>              <span class="c"># hit sequence, as a SeqRecord object</span>
<span class="go">SeqRecord(seq=Seq(&#39;CCCTCTACAGGGAAGCGCTTTCTGTTGTCTGAAAGAAAAGAAAGTGCTTCCTTT...GGG&#39;, DNAAlphabet()), id=&#39;gi|262205317|ref|NR_030195.1|&#39;, name=&#39;aligned hit sequence&#39;, description=&#39;Homo sapiens microRNA 520b (MIR520B), microRNA&#39;, dbxrefs=[])</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id2">
<h2>8.2  一个关于标准和惯例的注意事项<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>在我们进入到主要功能前，你需要知道 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 使用的一些标准。如果
你已经接触过多序列搜索工具，你可能必须面对每个程序处理事情方式不同的问题，
如序列位置坐标。这可能不是一个令人高兴的经历，因为这些搜索工具通常有它们
自己的标准。例如，一种工具可能使用“从1开始”(one-based)的坐标，而其他工具
使用“从0开始”(zero-based)的坐标。或者，一种程序在处理负链时，可能会反转
开始和结束坐标，而其他程序确不会。简而言之，会产生一些必须要处理的混乱。</p>
<p>我们意识到这种问题，并且打算在 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 中解决。毕竟， <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 的目标之一就是创建一个通用简单的接口来处理多种不同的搜索
输出文件。意味着要制定一个超越你所见的对象模型的标准。</p>
<p>现在，你可能抱怨，”不要又来一个标准“。好吧，最后我们必须选择一个标准，这
是必须的。并且，我们并不是创造一个全新的事物；只是采用一个我们觉得对Python
使用者最好的标准（这是Biopython，毕竟）。</p>
<p>在使用 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 时你可以认为有个三个隐含的标准：</p>
<ul class="simple">
<li>第一个适用于序列坐标。在 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 模块中，所有序列坐标遵循Python
的坐标风格：
从0开始，半开区间。例如，在一个BLAST XML输出文件中，HSP的起始和结束坐标
是10和28，它们在 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 中将变成9和28。起始坐标变成9因为Python
中索引是从0开始，而结束坐标仍然是28因为Python索引删除了区间中最后一个
项目。</li>
<li>第二个是关于序列坐标顺序。在 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 中，开始坐标总是小于或
等于结束坐标。但是这不是在所有的序列搜索工具中都始终适用。因为当序列
为负链时，起始坐标会更大一些。</li>
<li>最后一个标准是关于链和阅读框的值。对于链值，只有四个可选值： <tt class="docutils literal"><span class="pre">1</span></tt> (正链)， <tt class="docutils literal"><span class="pre">-1</span></tt> (负链)， <tt class="docutils literal"><span class="pre">0</span></tt> (蛋白序列)， 和 <tt class="docutils literal"><span class="pre">None</span></tt> (无链)。对于阅读框，
可选值是从 <tt class="docutils literal"><span class="pre">-3</span></tt> 至 <tt class="docutils literal"><span class="pre">3</span></tt> 的整型以及 <tt class="docutils literal"><span class="pre">None</span></tt> 。</li>
</ul>
<p>注意，这些标准只是存在于 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 对象中。如果你把 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt>
对象写入一种输出格式， <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 会使用该格式的标准来输出。它并不
强加它的标准到你的输出文件。</p>
</div>
<div class="section" id="id3">
<h2>8.3  读取搜索输出文件<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>有两个方法，你可以用来读取搜索输出文件到 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 对象： <tt class="docutils literal"><span class="pre">read</span></tt> 和 <tt class="docutils literal"><span class="pre">parse</span></tt>。
它们和其他亚模块如 <tt class="docutils literal"><span class="pre">Bio.SeqIO</span></tt> 或 <tt class="docutils literal"><span class="pre">Bio.AlignIO</span></tt> 中的 <tt class="docutils literal"><span class="pre">read</span></tt> 和 <tt class="docutils literal"><span class="pre">parse</span></tt> 方法在
本质上是相似的。你都需要提供搜索输出文件名和文件格式名，都是Python字符串类型。你可以
查阅文档来获得 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 可以识别的格式清单。</p>
<p><tt class="docutils literal"><span class="pre">Bio.SearchIO.read</span></tt> 用于读取单query的搜索输出文件并且返回一个 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象。你在前面的例子中已经看到过 <tt class="docutils literal"><span class="pre">read</span></tt> 的使用了。
你没看到的是， <tt class="docutils literal"><span class="pre">read</span></tt> 同样接受额外的关键字参数，取决于文件的格式。</p>
<p>这里有一些例子。在第一个例子中，我们和前面一样用 <tt class="docutils literal"><span class="pre">read</span></tt> 读BLAST表格输出
文件。在第二个例子中，我们用一个关键字来修饰，所以它分析带有注释的BLAST
表格变量。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SearchIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qresult</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s">&#39;tab_2226_tblastn_003.txt&#39;</span><span class="p">,</span> <span class="s">&#39;blast-tab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qresult</span>
<span class="go">QueryResult(id=&#39;gi|16080617|ref|NP_391444.1|&#39;, 3 hits)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qresult2</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s">&#39;tab_2226_tblastn_007.txt&#39;</span><span class="p">,</span> <span class="s">&#39;blast-tab&#39;</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qresult2</span>
<span class="go">QueryResult(id=&#39;gi|16080617|ref|NP_391444.1|&#39;, 3 hits)</span>
</pre></div>
</div>
<p>这些关键字在不同的文件格式中是不一样的。查看格式文档，看看它是否有关键字参数来控制它的分析器行为。</p>
<p>对于 <tt class="docutils literal"><span class="pre">Bio.SearchIO.parse</span></tt>，是用来读取含有任意数量query的搜索输出文件。
这个方法返回一个generator对象，在每次迭代中yield一个 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 对象。
和 <tt class="docutils literal"><span class="pre">Bio.SearchIO.read</span></tt> 一样，它同样接受格式特异的关键字参数：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SearchIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qresults</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#39;tab_2226_tblastn_001.txt&#39;</span><span class="p">,</span> <span class="s">&#39;blast-tab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">qresult</span> <span class="ow">in</span> <span class="n">qresults</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">qresult</span><span class="o">.</span><span class="n">id</span>
<span class="go">gi|16080617|ref|NP_391444.1|</span>
<span class="go">gi|11464971:4-101</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qresults2</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#39;tab_2226_tblastn_005.txt&#39;</span><span class="p">,</span> <span class="s">&#39;blast-tab&#39;</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">qresult</span> <span class="ow">in</span> <span class="n">qresults2</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">qresult</span><span class="o">.</span><span class="n">id</span>
<span class="go">random_s00</span>
<span class="go">gi|16080617|ref|NP_391444.1|</span>
<span class="go">gi|11464971:4-101</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>8.4  用索引处理含有大量搜索输出的文件<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>有时，你得到了一个包含成百上千个query的搜索输出文件要分析，你当然可以使用
<tt class="docutils literal"><span class="pre">Bio.SearchIO.parse</span></tt> 来处理，但是如果你仅仅需要访问少数query的话，效率
是及其低下的。这是因为 <tt class="docutils literal"><span class="pre">parse</span></tt> 会分析所有的query，直到找到你感兴趣。</p>
<p>在这种情况下，理想的选择是用 <tt class="docutils literal"><span class="pre">Bio.SearchIO.index</span></tt> 或 <tt class="docutils literal"><span class="pre">Bio.SearchIO.index_db</span></tt>
来索引文件。如果名字听起来很熟悉，是因为你之前已经见过了，在
Section <a class="reference external" href="#sec:SeqIO-index">5.4.2</a>。这些方法和 <tt class="docutils literal"><span class="pre">Bio.SeqIO</span></tt>
中相应的方法行为很相似，只是多了些格式特异的关键字参数。</p>
<p>这里有一些例子。你可以只用文件名和格式名来 <tt class="docutils literal"><span class="pre">index</span></tt></p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SearchIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;tab_2226_tblastn_001.txt&#39;</span><span class="p">,</span> <span class="s">&#39;blast-tab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;gi|11464971:4-101&#39;, &#39;gi|16080617|ref|NP_391444.1|&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="p">[</span><span class="s">&#39;gi|16080617|ref|NP_391444.1|&#39;</span><span class="p">]</span>
<span class="go">QueryResult(id=&#39;gi|16080617|ref|NP_391444.1|&#39;, 3 hits)</span>
</pre></div>
</div>
<p>或者依旧使用格式特异的关键字参数：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;tab_2226_tblastn_005.txt&#39;</span><span class="p">,</span> <span class="s">&#39;blast-tab&#39;</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;gi|11464971:4-101&#39;, &#39;gi|16080617|ref|NP_391444.1|&#39;, &#39;random_s00&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="p">[</span><span class="s">&#39;gi|16080617|ref|NP_391444.1|&#39;</span><span class="p">]</span>
<span class="go">QueryResult(id=&#39;gi|16080617|ref|NP_391444.1|&#39;, 3 hits)</span>
</pre></div>
</div>
<p>或者使用 <tt class="docutils literal"><span class="pre">key_function</span></tt> 参数，和 <tt class="docutils literal"><span class="pre">Bio.SeqIO</span></tt> 中一样：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">key_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="nb">id</span><span class="p">:</span> <span class="nb">id</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>    <span class="c"># capitalizes the keys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;tab_2226_tblastn_001.txt&#39;</span><span class="p">,</span> <span class="s">&#39;blast-tab&#39;</span><span class="p">,</span> <span class="n">key_function</span><span class="o">=</span><span class="n">key_function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;GI|11464971:4-101&#39;, &#39;GI|16080617|REF|NP_391444.1|&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="p">[</span><span class="s">&#39;GI|16080617|REF|NP_391444.1|&#39;</span><span class="p">]</span>
<span class="go">QueryResult(id=&#39;gi|16080617|ref|NP_391444.1|&#39;, 3 hits)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">Bio.SearchIO.index_db</span></tt> 和 <tt class="docutils literal"><span class="pre">index</span></tt> 作用差不多，不同的只是它把query
偏移量写入一个SQLite数据库文件中。</p>
</div>
<div class="section" id="id5">
<h2>8.5  写入和转换搜索输出文件<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>有时候，读取一个搜索输出文件，作些调整并写到一个新的文件是很有用的。
<tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 提供了一个 <tt class="docutils literal"><span class="pre">write</span></tt> 方法，让你可以准确地完成这种工作。
它需要的参数是：一个可迭代返回 <tt class="docutils literal"><span class="pre">QueryResult</span></tt> 的对象，输出文件名，输出文件
格式和一些可选的格式特异的关键字参数。它返回一个4项目的元组，分别代表
被写入的 <tt class="docutils literal"><span class="pre">QueryResult</span></tt>， <tt class="docutils literal"><span class="pre">Hit</span></tt>， <tt class="docutils literal"><span class="pre">HSP</span></tt>， 和 <tt class="docutils literal"><span class="pre">HSPFragment</span></tt> 对象的数量。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SearchIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qresults</span> <span class="o">=</span> <span class="n">SearchIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#39;mirna.xml&#39;</span><span class="p">,</span> <span class="s">&#39;blast-xml&#39;</span><span class="p">)</span>     <span class="c"># read XML file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SearchIO</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">qresults</span><span class="p">,</span> <span class="s">&#39;results.tab&#39;</span><span class="p">,</span> <span class="s">&#39;blast-tab&#39;</span><span class="p">)</span>    <span class="c"># write to tabular file</span>
<span class="go">(3, 239, 277, 277)</span>
</pre></div>
</div>
<p>你应该注意，不同的文件格式需要 <tt class="docutils literal"><span class="pre">QueryResult</span></tt>， <tt class="docutils literal"><span class="pre">Hit</span></tt>， <tt class="docutils literal"><span class="pre">HSP</span></tt> 和
<tt class="docutils literal"><span class="pre">HSPFragment</span></tt> 对象的不同属性。如果这些属性不存在，那么将不能写入。
也就是，你想写入的格式可能有时也会失效。举个例子，如果你读取一个BLASTXML文件，
你就不能将结果写入PSL文件，因为PSL文件需要一些属性，而这些属性BLAST却不能
提供（如重复匹配的数量）。如果你确实想写到PSL，可以手工设置这些属性。</p>
<p>和 <tt class="docutils literal"><span class="pre">read</span></tt>， <tt class="docutils literal"><span class="pre">parse</span></tt>， <tt class="docutils literal"><span class="pre">index</span></tt> 和 <tt class="docutils literal"><span class="pre">index_db</span></tt> 相似， <tt class="docutils literal"><span class="pre">write</span></tt> 同
样接受格式特异的关键字参数。查阅文档获得 <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 可写格式和这些
格式的参数的完整清单。</p>
<p>最后， <tt class="docutils literal"><span class="pre">Bio.SearchIO</span></tt> 同样提供一个 <tt class="docutils literal"><span class="pre">convert</span></tt> 方法，可以理解为 <tt class="docutils literal"><span class="pre">Bio.SearchIO.parse</span></tt> 和 <tt class="docutils literal"><span class="pre">Bio.SearchIO.write</span></tt> 的简单替代方法。使用 <tt class="docutils literal"><span class="pre">convert</span></tt> 方法的例子如下：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">SearchIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SearchIO</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s">&#39;mirna.xml&#39;</span><span class="p">,</span> <span class="s">&#39;blast-xml&#39;</span><span class="p">,</span> <span class="s">&#39;results.tab&#39;</span><span class="p">,</span> <span class="s">&#39;blast-tab&#39;</span><span class="p">)</span>
<span class="go">(3, 239, 277, 277)</span>
</pre></div>
</div>
<p>因为 <tt class="docutils literal"><span class="pre">convert</span></tt> 使用 <tt class="docutils literal"><span class="pre">write</span></tt> 方法，所以只有所有需要的属性都存在时，格式
转换才能正常工作。这里由于BLAST XML文件提供BLAST 表格文件所需的所有默认值，
格式转换才能正常完成。但是，其他格式转换就可能不会正常工作，因为你需要先手工指定所需的属性。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">第8章  BLAST和其他序列搜索工具(<em>实验性质的代码</em>)</a><ul>
<li><a class="reference internal" href="#searchio">8.1  SearchIO对象模型</a><ul>
<li><a class="reference internal" href="#queryresult">8.1.1  QueryResult</a></li>
<li><a class="reference internal" href="#hit">8.1.2  Hit</a></li>
<li><a class="reference internal" href="#hsp">8.1.3  HSP</a></li>
<li><a class="reference internal" href="#id1">8.1.4  HSP片段</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id2">8.2  一个关于标准和惯例的注意事项</a></li>
<li><a class="reference internal" href="#id3">8.3  读取搜索输出文件</a></li>
<li><a class="reference internal" href="#id4">8.4  用索引处理含有大量搜索输出的文件</a></li>
<li><a class="reference internal" href="#id5">8.5  写入和转换搜索输出文件</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="chr07.html"
                        title="previous chapter">第7章  BLAST</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="chr09.html"
                        title="next chapter">第9章  访问NCBI Entrez数据库</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/chr08.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="chr09.html" title="第9章 访问NCBI Entrez数据库"
             >next</a> |</li>
        <li class="right" >
          <a href="chr07.html" title="第7章 BLAST"
             >previous</a> |</li>
        <li><a href="index.html">biopython_cn 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, biopythoners.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>